#!/usr/bin/perl

# use lib qw(/home/rork/Scripts/lib);
use LWP::Simple;
use File::Copy;
use File::Basename;
use Getopt::Long;
use HTML::LinkExtor;
use uIni;
use upkg;
use strict;
use warnings;

# CHANGELOG
# v0.1
#   - basic script
# v0.2
#   - Overwrite the ini on update (requires latest uIni.pm)
#   - Replace utdep.pl by upkg.pm
#   - Case insensitive search on repair
#   - Add --fix-mismatch
# v0.4
#   - Fixed case in downloading files
#   - Fixes in getPath()
#   - Improve case insensitive file searching
#   - Easier version of repair (only searches the indicated directory now)
#   - Fixed bug in saving uz-get.new_ini
#   - Added multiple direction support
#   - Changed behaviour of makePath (returns path within utdir)
#   - Backup mismatched files and restore if available
#
# TODO
#   - check for http errors
#   - update single repositories
#   - add an upgrade function?
#   - incorperate udecache

# set some variables

# first dir is where the all the files are stored, this must contain the System/uz-get.ini and must be where ucc stores its files.
my @utdirs = ("/home/rork/.loki/ut/", "/home/rork/Games/ut/");
my $pathToUcc = "/home/rork/Games/ut/ucc";
my $pathToLog = "/home/rork/.loki/ut/System/UnrealTournament.log";

# fixed variables
my $version = '0.4';


GetOptions("d|download=s" => \&download, "h|help" => \&help, "r|repair=s" => \&repair, "u|update" => \&update, "s|search=s" => \&search, "i|install=s" => \&install, "f|fix-mismatch" => \&fixMismatch);

sub download {
  # the most important part of the script, downloads, decompresses and moves the file.
  my $self = shift;
  my $file = shift;
  my $filename = $file;
     $filename =~ s/^.*\///;

  # create the cachename and the packagename
  my $storename = $utdirs[0] . makePath($filename);
     $filename =~ s/\.uz$//i;
     
  my $packagename = getPath($filename);
    
  if (defined($packagename)) {
    print "Package $filename allready exists\n";
    return;
  }

  # download and store the file

  unless (-e $storename) {
    print "Downloading $file\n";
    getstore($file, $storename);
  }
  else {
    print "Get $filename from Cache\n";
  }
  
  if ($storename =~ m/\.uz$/) {
    print "Decompress $storename\n";
    $storename =~ s/\(/\\\(/g;
    $storename =~ s/\)/\\\)/g;
    system($pathToUcc . " decompress " . $storename);
  }
  
  unless (-e $ENV{'HOME'} . "/.loki/ut/System/" . $filename) {
    opendir(DIR, $ENV{'HOME'} . "/.loki/ut/System/");
    foreach (readdir(DIR)) {
      if (lc($_) eq lc($filename)) {
        $filename = $_;
      }
    }
  }
  
  $packagename = $utdirs[0] . makePath($filename);
  
  print "Move to " . $packagename . "\n";
  move($utdirs[0] . "/System/" . $filename ,$packagename) or die "Can't move package (" . $utdirs[0] . "/.loki/ut/System/" . $filename . ": $!";
}

sub install {
  my $self = shift;
  my $query = shift;

  # first find available url's
  my @urls;

  open(FILE, "<", $utdirs[0] . "/System/uz-get.ini") or die "Can't open FILE: $!";
  while(<FILE>) {
    if ($_ =~ m/file.*\/$query\.uz/i) {
      s/[\r\n]//g;
      s/file\[\d+\]=//i;
      push(@urls, $_);
    }
  }
  close(FILE);
  if ($#urls == -1) {
    print "File ($query) not found\n";
    return;
  }

  # choose a random url, should build a decent loadbalancer
  my $rand = srand($#urls);
  # print "Get url $rand\n";

  # download file and dependencies
  download(undef, $urls[$rand-1]);
  repair(undef, $query);
}

sub help {
  print <<HelpText;
uz-get v$version
search and download ut files from redirectservers

Usage: uz-get -dhirsuf ?file?

Options:
   -d   --download URL      Downloads and install a networkpackage
   -h   --help              This help text
   -i   --install  PACKAGE  Searches and downloads a package
   -r   --repair   PACKAGE  Checks for and installs missing dependencies
   -s   --search   PACKAGE  Search for the package in the repository
   -u   --update            Update the filelist
   -f   --fix-mismatch      Check the UnrealTournament.log for version mismatches and missing files

HelpText
}

sub search {
  my $self = shift;
  my $query = shift;
  my %results;

  open(FILE, "<", $utdirs[0] . "/System/uz-get.ini") or die "Can't open FILE uz-get.ini: $!";
  while(<FILE>) {
    if ($_ =~ m/\/[^\/]*$query[^\/]*$/i) {
      $_ =~ s/[\r\n]//g;
      $_ =~ s/.*\///;
      $_ =~ s/\.uz$//i;
      $results{lc($_)}++;
    }
  }
  close(FILE);

  print join("\n", sort keys %results);
  print "\n\n";
}

sub repair {
  my $self = shift;
  my $pkg = shift;


  $pkg =~ s/\(/\\\(/g;
  $pkg =~ s/\)/\\\)/g;

  # get the filetype
     $pkg =~ m/\.(u[mxnrat]*)/i;
  my $type = lc($1);

  # check if the file exists
  my $pkgPath = getPath($pkg);
  unless (-e $pkgPath) {
    print "Can't repair $pkg: file not found\n";
    return;
  }

  # get the dependencies
  my $opkg = upkg->new();
     $opkg->load($pkgPath);
     
  my @deps = $opkg->getDependencies();
  
  foreach my $dependency (@deps) {
    if ($dependency =~ m/\.uxx$/i) {
      print "Ignore $dependency: extension not found\n";
      next;
    }
    my $path = getPath($dependency);
    if (!defined($path)) {
      install(undef, $dependency);
    }
  }
}

sub update {
  my $ini = uIni->new();
     $ini->load($utdirs[0] . "System/uz-get.ini");
  my $new_ini = uIni->new();
  my $i = 0;
  my $numFiles = 0;
  while(1) {
    my @files;
    my $repository = $ini->getValue("uz-get.files", "Repository", $i);
    unless (defined($repository)) {
      last;
    }
    $new_ini->setValue("uz-get.files", "Repository[$i]", $repository);
    print "Get $repository\n";

    # fetch the page 
    my $page =  get($repository);
    my $parser = new HTML::LinkExtor (sub {my ($tag, %links) = @_; push(@files, values(%links))});
       $parser->parse ($page);
       $parser->eof;
    foreach my $file(@files) {
      next unless ($file =~ m/.uz$/i);
      if ($file !~ m/^http/i) {
        $file =~ s/^\///;
        $file = $repository . $file;
      }
      # print "Found: $file\n";
      $new_ini->setValue("uz-get.files", "file[$numFiles]", $file);
      $numFiles++;
    }
    $i++;
  }
  $new_ini->save($utdirs[0] . "System/uz-get.ini");
}

sub fixMismatch {
  my %files;
  my $redirect;
  my $compression = 0;
  
  open(LOG, "<", $pathToLog) or die "Can't open log ($pathToLog): $!\n";
  while(<LOG>) {
    chomp;
    my @line = split(/\s+/);
    
    # detect new connection:
    # Log: Browse: 176.57.143.206/Index.unr?Name=Rork?Class=BotPack.TMale1?team=0?skin=CommandoSkins.daco?Face=CommandoSkins.Boris?Voice=BotPack.VoiceMaleOne?OverrideClass=
    if ($line[0] eq "Log:" and $line[1] eq "Browse:") {
      # reconnect, reset the files
      print "Switch map\n";
      %files = ();
    }
    
    # detect packages
    # DevNet: PendingLevel received: USES GUID=B9D3048E4988166ADE95A99FF86E339E PKG=MH-ATAA0-(Obnoxious)+fix2 FLAGS=1 SIZE=1001070 GEN=1 FNAME=MH-ATAA0-(Obnoxious)+fix2.unr
    if ($line[0] eq "DevNet:" and $line[1] eq "PendingLevel" and $line[3] eq "USES") {
      my $guid = substr($line[4], 5);
      my $file = substr($line[9], 6);
      $files{$file} = $guid;
    }
    
    # detect redirect
    # DevNet: PendingLevel received: DLMGR CLASS=IpDrv.HTTPDownload PARAMS=http://176.57.143.206/redirect/ COMPRESSION=1
    if ($line[0] eq "DevNet:" and $line[1] eq "PendingLevel" and $line[3] eq "DLMGR" and $line[4] eq "CLASS=IpDrv.HTTPDownload") {
      $redirect = substr($line[5], 7);
      $compression = substr($line[6], -1);
    }
  }
  close(LOG);
  
  if (!defined($redirect)) {
    print "No redirect found, can't do anything\n";
    exit;
  }
  
  if ($redirect !~ m/\/$/) {
    $redirect .= "/";
  }
  print "Redirect: $redirect\n";
  print "Compression: $compression\n";
  print "Files: " . (scalar(keys  %files) + 1) . "\n\n";
  
  foreach my $file (sort {lc($a) cmp lc($b)} keys %files) {
    print $file;
    
    
    my $guid = $files{$file};

    my $path = getPath($file);
    my $link = $redirect . $file;
    if ($compression) {
      $link .= ".uz";
    }
    if (!defined($path)) {
      print " [DOWNLOAD]\n";

      download(undef, $link);
    }
    else {
      my $pkg = upkg->new;
         $pkg->load($path);
         
      my $curguid = $pkg->{'headers'}->{'GUID'};
      my $version = $pkg->{'headers'}->{'Version'};
      
      if ($version < 68) {
        print " [NO GUID]\n";
      }
      else {
        $curguid =~ s/-//g;
        $curguid = uc($curguid);
                
        if ($guid eq $curguid) {
          print " [OK]\n";
        }
        else {
          print " [REPLACE]\n";
          my $backup = $utdirs[0] . "Cache/" . $file . "-" . $curguid;
          move($path, $backup);
          
          print "old: " . $curguid . "\n";
          print "new: " . $guid . "\n";

          my $cache = $utdirs[0] . "Cache/" . $file . "-" . $guid;
          if (-e $cache) {
            print "Move $file Cache\n";
            move($cache, $path);
          }
          else {            
            my $cache = getPath($file . ".uz");
            if (-e $cache) {
              print "Remove $file.uz from Cache\n";
              unlink($cache);
            }
          
            my $link = $redirect . $file;
            if ($compression) {
              $link .= ".uz";
            }
            download(undef, $link);
          }
        }
      }
    }
  }
}

sub getPath {
  # case insensitive search for paths of existing files
  my $file = shift;
  
  my $dir = dirname($file);
  my $filename = basename($file);
  
  my $pkgPath;
    
  if ($dir ne ".") {
    $pkgPath = $file;
  }
  else {
    $pkgPath = makePath($file);
  }
  
  foreach my $utdir (@utdirs) {
    # check if the file exists
    unless (-e $utdir . $pkgPath) {
      # no, case insensitive search
      my $dir = dirname($utdir . $pkgPath);
      opendir(DIR, $dir);
      foreach (readdir(DIR)) {
	if (lc($_) eq lc($filename)) {
	  $pkgPath = $dir . "/" . $_;
	}
      }
    }
    else {
      $pkgPath = $utdir . $pkgPath;
    }
    #check again
    if (-e $pkgPath) {
      return $pkgPath;
    }
  }
  return undef;
}

sub makePath {
  # make the expected path of a file
  my %type2dir = (
  "u" => "System/",
  "unr" => "Maps/",
  "umx" => "Music/",
  "utx" => "Textures/",
  "uax" => "Sounds/",
  "uz" => "Cache/");
  
  my $file = shift;
     $file =~ m/\.(u[mxnratz]*$)/i;
     
  my $type = lc($1);
  
  my $pkgPath = $type2dir{$type} . $file;
  
  return $pkgPath;
}
