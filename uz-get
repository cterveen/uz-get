#!/usr/bin/perl

use lib qw(/home/rork/Scripts/lib);
use LWP::Simple;
use File::Copy;
use Getopt::Long;
use HTML::LinkExtor;
use uIni;
use upkg;
use strict;
use warnings;

# CHANGELOG
# v0.1
#   - basic script
# v0.2
#   - Overwrite the ini on update (requires latest uIni.pm)
#   - Replace utdep.pl by upkg.pm
#   - Case insensitive search on repair
#   - Add --fix-mismatch
#
# TODO
#   - check for http errors
#   - support local repositories
#   - update single repositories
#   - build in load balancer
#   - build repository management, opening a 4MB file might not be easy
#   - add an upgrade function?

# set some variables
my $utdir = "/home/rork/tmp/UT/";
my $cachedir = $utdir . "Cache/";
my $pathToUcc = "/home/rork/Games/ut/ucc";
my $pathToLog = "/home/rork/.loki/ut/System/UnrealTournament.log";

# fixed variables
my $version = '0.2';
my %type2dir = (
  "u" => "System/",
  "unr" => "Maps/",
  "umx" => "Music/",
  "utx" => "Textures/",
  "uax" => "Sounds/");

GetOptions("d|download=s" => \&download, "h|help" => \&help, "r|repair=s" => \&repair, "u|update" => \&update, "s|search=s" => \&search, "i|install=s" => \&install, "f|fix-mismatch" => \&fixMismatch);

sub download {
  # the most important part of the script, downloads, decompresses and moves the file.
  my $self = shift;
  my $file = shift;
  my $filename = $file;
     $filename =~ s/^.*\///;

  # get the filetype
     $filename =~ m/\.(u[mxnrat]*)\.uz/i;
  my $type = lc($1);

  # create the cachename and the packagename
  my $storename = $cachedir . $filename;
     $filename =~ s/\.uz$//i;
  my $packagename = $utdir . $type2dir{$type} . $filename;

  if (-e $packagename) {
    print "Package $filename allready exists\n";
    exit;
  }

  # download and store the file
  print "Downloading $file\n";

  unless (-e $storename) {
    getstore($file, $storename);
  }
  
  if ($storename =~ m/\.uz$/) {
    print "Decompress $filename\n";
    $storename =~ s/\(/\\\(/g;
    $storename =~ s/\)/\\\)/g;
    system($pathToUcc . " decompress " . $storename);
  }
  
  unless (-e $ENV{'HOME'} . "/.loki/ut/System/" . $filename) {
    opendir(DIR, $ENV{'HOME'} . "/.loki/ut/System/");
    foreach (readdir(DIR)) {
      if (lc($_) eq lc($file)) {
        $filename = $_;
      }
    }
  }
  print "Move to " . $packagename . "\n";
  move($ENV{'HOME'} . "/.loki/ut/System/" . $filename ,$packagename) or die "Can't move package (" . $ENV{'HOME'} . "/.loki/ut/System/" . $filename . ": $!";
}

sub install {
  my $self = shift;
  my $query = shift;

  # first find available url's
  my @urls;

  open(FILE, "<", $utdir . "/System/uz-get.ini") or die "Can't open FILE: $!";
  while(<FILE>) {
    if ($_ =~ m/file.*\/$query\.uz/i) {
      s/[\r\n]//g;
      s/file\[\d+\]=//i;
      push(@urls, $_);
    }
  }
  close(FILE);
  if ($#urls == -1) {
    print "File ($query) not found\n";
    return;
  }

  # choose a random url, should build a decent loadbalancer
  my $rand = srand($#urls);
  # print "Get url $rand\n";

  # download file and dependencies
  download(undef, $urls[$rand-1]);
  repair(undef, $query);
}

sub help {
  print <<HelpText;
uz-get v$version
search and download ut files from redirectservers

Usage: uz-get -dhirsuf ?file?

Options:
   -d   --download URL      Downloads and install a networkpackage
   -h   --help              This help text
   -i   --install  PACKAGE  Searches and downloads a package
   -r   --repair   PACKAGE  Checks for and installs missing dependencies
   -s   --search   PACKAGE  Search for the package in the repository
   -u   --update            Update the filelist
   -f   --fix-mismatch      Check the UnrealTournament.log for version mismatches and missing files

HelpText
}

sub search {
  my $self = shift;
  my $query = shift;
  my %results;

  open(FILE, "<", $utdir . "/System/uz-get.ini") or die "Can't open FILE uz-get.ini: $!";
  while(<FILE>) {
    if ($_ =~ m/\/[^\/]*$query[^\/]*$/i) {
      $_ =~ s/[\r\n]//g;
      $_ =~ s/.*\///;
      $_ =~ s/\.uz$//i;
      $results{lc($_)}++;
    }
  }
  close(FILE);

  print join("\n", sort keys %results);
  print "\n\n";
}

sub repair {
  my $self = shift;
  my $pkg = shift;


  $pkg =~ s/\(/\\\(/g;
  $pkg =~ s/\)/\\\)/g;

  # get the filetype
     $pkg =~ m/\.(u[mxnrat]*)/i;
  my $type = lc($1);

  # check if the file exists
  my $pkgPath = $utdir . $type2dir{$type} . $pkg;
  unless (-e $pkgPath) {
    print "Case-insensitive search\n";
    opendir(DIR, $utdir . $type2dir{$type});
    foreach (readdir(DIR)) {
      if (lc($_) eq lc($pkg)) {
        $pkgPath = $utdir . $type2dir{$type} . $_;
      }
    }
    
    #check again
    unless (-e $pkgPath) {
      print "Can't repair $pkg: file not found\n";
      return;
    }
  }

  # get the dependencies
  my $opkg = upkg->new();
     $opkg->load($pkgPath);
     
  my @deps = $opkg->getDependencies();

  my %installed;
  # check if the dependencies exist, if not install them, must be case insensitive so get a list of files
  foreach my $subdir(values %type2dir) {
    opendir(DIR, $utdir . $subdir) or die "Can't read DIR: $!";
    map($installed{lc($_)} = "", readdir(DIR));
    closedir(DIR);

    if (-e $ENV{'HOME'} . "/.loki/ut/" . $subdir) {
      opendir(DIR, $ENV{'HOME'} . "/.loki/ut/" . $subdir) or die "Can't read DIR: $!";
      map($installed{lc($_)} = "", readdir(DIR));
      closedir(DIR);
    }

    if (-e $ENV{'HOME'} . "/Games/ut/") {
      opendir(DIR, $ENV{'HOME'} . "/Games/ut/" . $subdir) or die "Can't read DIR: $!";
      map($installed{lc($_)} = "", readdir(DIR));
      closedir(DIR);
    }
  }

  foreach my $dep(@deps) {
    next unless ($dep =~ m/\.(u[mxnrat]*)/i);
    if (!exists($installed{lc($dep)})) {
      install(undef, $dep);
    }
  }
}

sub update {
  my $ini = uIni->new();
     $ini->load($utdir . "System/uz-get.ini");
  my $new_ini = uIni->new();
  my $i = 0;
  my $numFiles = 0;
  while(1) {
    my @files;
    my $repository = $ini->getValue("uz-get.files", "Repository", $i);
    $new_ini->setValue("uz-get.files", "Repository", $i, $repository);
    unless (defined($repository)) {
      last;
    }
    print "Get $repository\n";
    # fetch the page 
    my $page = get($repository);
    my $parser = new HTML::LinkExtor (sub {my ($tag, %links) = @_; push(@files, values(%links))});
       $parser->parse ($page);
       $parser->eof;
    foreach my $file(@files) {
      next unless ($file =~ m/.uz$/i);
      if ($file !~ m/^http/i) {
        $file =~ s/^\///;
        $file = $repository . $file;
      }
      # print "Found: $file\n";
      $new_ini->setValue("uz-get.files", "file", $numFiles, $file);
      $numFiles++;
    }
    $i++;
  }
  $new_ini->save($utdir . "System/uz-get.ini");
}

sub fixMismatch {
  my %files;
  my $redirect;
  my $compression = 0;
  
  open(LOG, "<", $pathToLog) or die "Can't open log ($pathToLog): $!\n";
  while(<LOG>) {
    chomp;
    my @line = split(/\s+/);
    
    # detect new connection:
    # Log: Browse: 176.57.143.206/Index.unr?Name=Rork?Class=BotPack.TMale1?team=0?skin=CommandoSkins.daco?Face=CommandoSkins.Boris?Voice=BotPack.VoiceMaleOne?OverrideClass=
    if ($line[0] eq "Log:" and $line[1] eq "Browse:") {
      # reconnect, reset the files
      print "Switch map\n";
      %files = ();
    }
    
    # detect packages
    # DevNet: PendingLevel received: USES GUID=B9D3048E4988166ADE95A99FF86E339E PKG=MH-ATAA0-(Obnoxious)+fix2 FLAGS=1 SIZE=1001070 GEN=1 FNAME=MH-ATAA0-(Obnoxious)+fix2.unr
    if ($line[0] eq "DevNet:" and $line[1] eq "PendingLevel" and $line[3] eq "USES") {
      my $guid = substr($line[4], 5);
      my $file = substr($line[9], 6);
      $files{$file} = $guid;
    }
    
    # detect redirect
    # DevNet: PendingLevel received: DLMGR CLASS=IpDrv.HTTPDownload PARAMS=http://176.57.143.206/redirect/ COMPRESSION=1
    if ($line[0] eq "DevNet:" and $line[1] eq "PendingLevel" and $line[3] eq "DLMGR" and $line[4] eq "CLASS=IpDrv.HTTPDownload") {
      $redirect = substr($line[5], 7);
      $compression = substr($line[6], -1);
    }
  }
  close(LOG);
  
  if (!defined($redirect)) {
    print "No redirect found, can't do anything\n";
    exit;
  }
  
  if ($redirect !~ m/\/$/) {
    $redirect .= "/";
  }
  print "Redirect: $redirect\n";
  print "Compression: $compression\n";
  print "Files: " . (scalar(keys  %files) + 1) . "\n\n";
  
  foreach my $file (sort {lc($a) cmp lc($b)} keys %files) {
    print $file;
    
    
    my $guid = $files{$file};

    my $path = getPath($file);
    my $link = $redirect . $file;
    if ($compression) {
      $link .= ".uz";
    }
    if (!defined($path)) {
      print " [DOWNLOAD]\n";

      download(undef, $link);
    }
    else {
      my $pkg = upkg->new;
         $pkg->load($path);
         
      my $curguid = $pkg->{'headers'}->{'GUID'};
      my $version = $pkg->{'headers'}->{'Version'};
      
      if ($version < 68) {
        print " [NO GUID]\n";
      }
      else {
        $curguid =~ s/-//g;
        $curguid = uc($curguid);
                
        if ($guid eq $curguid) {
          print " [OK]\n";
        }
        else {
          print " [REPLACE]\n";
          unlink($path);
          
          print "old: " . $curguid . "\n";
          print "new: " . $guid . "\n";
          
          my $link = $redirect . $file;
          if ($compression) {
            $link .= ".uz";
          }
          download(undef, $link);
        }
      }
    }
  }
}

sub getPath {
  my $file = shift;
  
  # get the filetype
     $file =~ m/\.(u[mxnrat]*)/i;
  my $type = lc($1);
  
  my $pkgPath = $utdir . $type2dir{$type} . $file;
  unless (-e $pkgPath) {
    opendir(DIR, $utdir . $type2dir{$type});
    foreach (readdir(DIR)) {
      if (lc($_) eq lc($file)) {
        $pkgPath = $utdir . $type2dir{$type} . $_;
      }
    }
    
    #check again
    unless (-e $pkgPath) {
      return;
    }
  }
  return $pkgPath;
}
